版本 3.2.1

注 未看标记为*****

jQuery 代码结构分析

首先定义一堆私有变量

记录变量，或者单看看不出意思的。

var class2type = {};

var toString = class2type.toString;   // 猜测为toString.call(variable)

null -> [object Null]
undefiend -> [object Undefiend]
new Date() -> [object Date]
new ClassA() -> [obect Object]


之后补充个知识

typeof Object
// "function"
typeof Object()
// "object"

因为 Object 是一个构造函数

其后再补充 Function 与 Object

https://segmentfault.com/q/1010000002736664
https://segmentfault.com/q/1010000000249140

目前感觉很绕，需抽空研究

var hasOwn = class2type.hasOwnProperty;

{}.hasOwnProperty 与 Object.prototype.hasOwnProperty 相同

因为 {} 与 new Object()

但是不要忘了 {} 与 Object.prototype 是不同的

例： hasOwnProperty 判断是否含有特定的自身属性

{}.hasOwnProperty('toString');  // false
Object.prototype.hasOwnProperty('toString'); // true

补充 for in 是会遍历原型链的，但是不会遍历不可枚举的属性

再补充 in 可以是不可枚举属性
'toString' in {}; // true

Object.getOwnPropertyNames 就可以输出 hasOwnProperty 的所有属性
Object.keys 是只能输出可枚举的

以上两个均是自身特定的，不会遍历原型链

var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call( Object );

如果要循环全部 需要一层一层原型链遍历
使用 Object.getPrototypeOf

类似这样 while (obj = Object.getPrototypeOf(obj));


var fnToString = hasOwn.toString;


直接调用 fnToString() 是会报错的，一开始用 FireBug 一直不知道错在哪，
一直报错 TypeError: Function.prototype.toString called on incompatible object
其后用 Chrome 报错 Uncaught TypeError: Function.prototype.toString requires that 'this' be a Function
明显多了，this 改动了，虽然不知道toString的源码是什么，但也能判断出来大概。

以 Object 做判断 

var a = {b: 1};

var b = a.toString;

b();

FireBug 输出是 "[object Window]"
Chrome 输出是 "[object Undefined]"

可知源码必是用了 this 来输出结果

根据知乎 https://www.zhihu.com/question/19636194 方应杭的答案

this 三中调用形式

func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2)


看第一种

function func() {
	console.log(this)
}

func();

可等价为 func.call(undefiend) // 可简写为 func.call()

按理就是 undefined, 但浏览器中如果你传的 context 不是一个对象，那么 window 对象就是默认的 context。
（这条规则在 Node.js 和 strict 模式下会稍微不一样，不过那不是我们现在要讨论的）

看第二种

var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo();

可等价为 obj.foo.call(obj), this 就是 obj 了

看第三种

直接定了 context 了


现在可以知道了，举个例子

Object.prototype.test = function () {
	console.log(this);
}

var a = {x: 1};

a.test();  // 此处this就是a

var b = a.test;

b(); // 此处this就是window


之后知乎里面一道 this 的题目

var a = 10;
function test() {
    a = 5;
	console.log(a);
	console.log(this.a);
	var a;
	console.log(this.a);
	console.log(a);
}

问：执行test()和new test() 返回值分别为啥？

此处涉及变量提前

a = 10;
var a;
console.log(a);

输出的是 10

答案是 5 10 10 5
       5 undefined undefined 5



function DOMEval( code, doc ) {
	doc = doc || document;

	var script = doc.createElement( "script" );

	script.text = code;
	doc.head.appendChild( script ).parentNode.removeChild( script );
}

appendChild 后立马 removeChild

单看认为是实现 once 功能
但自己目前对这样写的实际效果保持怀疑


jQuery = function( selector, context ) {
	// The jQuery object is actually just the init constructor 'enhanced'
	// Need init if jQuery is called (just allow error to be thrown if not included)
	return new jQuery.fn.init( selector, context );
},

猜能猜到是创建一个jQuery对象
目前该函数尚未遇见，做个标记*****。


rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

https://imququ.com/post/bom-and-javascript-trim.html

 \uFEFF。它是 ES5 新增的空白符，叫字节次序标记字符（Byte Order Mark），也就是 BOM 字符。


fcamelCase = function( all, letter ) {
	return letter.toUpperCase();
};

作为 replace 的第二个参数


其后定义了 jQuery.fn


提前看
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

就是把两个数组或类数组对象合并


pushStack: function( elems ) {
	// Build a new jQuery matched element set
	var ret = jQuery.merge( this.constructor(), elems );
	
	// Add the old object onto the stack (as a reference)
	ret.prevObject = this;

	// Return the newly-formed element set
	return ret;
},

即创建一个新的jQuery对象，且放入新的elem，原先的扔在pervObject

目前可以取消链式调用的方法，如 eq find 等等都用了此函数，jQuery 的强大的链式调用关键方法

做标记***** 遇到 end 回来距离用

做标记***** 后期 jQuery 的方法与 underscore 比较 (each, map 这些)


定义 jQuery 与 jQuery.fn 的 extend 方法

照着敲了一遍

jQuery.extend = jQuery.fn.extend = function () {
	var options, name, src, copy, copyIsArray, clone,
	    target = arguments[ 0 ] || {},
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// 函数重载，判断是否深复制，默认浅复制
	if ( typeof target === 'boolean' ) {
		deep = target;

		target = arguments[i] || {};
		i++;
	}

	// 处理target为string或其他的情况，可能发生在深复制
	if ( typeof target !== 'object' && !jQuery.isFunction ( target) ) {
		target = {};
	}

	// 当只有一个参数时，extend jQuery 自己本身
	if (i === length) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// 感觉此处不合理，用 != 而不是 !== 而且为了排除null与undefined
		// 用 if (options) 更好
		// for in 对null 和 undefined 也不会报错
		if ( ( options = arguments[ i ] ) != null ) {

			for ( name in options) {
				src = target[ name ];
				copy = options[ name ];

				// 防止无限递归的对象
				// var a = {b: 1}
				// extend(a, {x: a});
				if (target === copy ) {
					continue;
				}

				// recurse 递归
				if ( deep && copy && jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy )) {

					if ( copyIsArray ) {
						// 目前不清楚为何要重置copyIsArray，完全没作用
						// 然而是有很大作用的，因为此次为循环，且copyIsArray是“或”语句，因此需要重置copyIsArray
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];
					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					target[ name ] = jQuery.extend( deep, clone, copy);
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	return target;
}


extend 函数补充知识点

关于typeof

typeof null === 'object';
typeof [1, 2, 3] === 'object'; 

// instaitated with  与...联系在一起
// All constructor function while instaitated with 'new' keyword will always be typeof 'object'
typeof new Number(100) === 'object';
// But there is a exception in case of Function constructor of Javascript
typeof new Function() === 'function';

typeof /s/ === 'function'; // Non-conform to ECMAScript 5.1
typeof /s/ === 'object';   // Conform to ECMAScript 5.1

关于 for in

var str = 'abc';
for (var key in str) {
	console.log(key);
}

// 0
// 1
// 2


紧接着 extend jQuery 对象
一堆 isXXX 函数 
此处也是够6，我应该不敢这么写，此处应该是算 jQuery 奇淫技巧之一。
extend 函数用到了需要 extend 的函数。
如 jQuery 本身没有 isFunction 但是 extend 函数用了 isFunction
isFunction 是需要 extend 的属性


expando 是 expandable object 的缩写,表示可扩展的对象


目前未知 noop 是干什么的，跟本没用到

介绍 isWindow

isWindow: function ( obj ) {
	return obj != null && obj === obj.window
}

window 对象的 window 属性指向他自己本身，截取段 MDN 的解释
The window property of a window object points to the window object itself. Thus the following expressions all return the same window object

介绍 isNumeric 

isNumeric: function ( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)	
	var type = jQuery.type( obj );
	return ( type === 'number' || type === 'string') &&
	
		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
}

那堆英语我也不知道怎么翻译

先判断是否 数字 或 字符串
且 !isNaN( obj - parseFloat( obj ) )

一开始有个疑惑，为甚不直接 obj - obj

是为了排除 '' 即空字符串的情况

其后补充知识

减法会强制转换类型

null '' Boolean值 都会强制转换为数字

parseFloat 则没这种情况，但是 parseFloat 有其他问题
其会将'Ox15'这样的值转换为 0 
会将 [6, 8] 数组转换成第一个数字(空数组没问题，对象也没问题)


isPlainObject: function ( obj ) {
	var proto, Ctor;

	if ( !obj || toString.call( obj ) !== '[object object]') {
		return false;
	}

	proto = getProto( obj );

	if ( !proto ) {
		return true;
	}

	Ctor = hasOwn.call( proto, 'constructor' ) && proto.constructor;
	return typeof Ctor === 'function' && fnToString.call( Ctor) === ObjectFunctionString
}

判断对象是否简单对象，即使用 {} 或 new Object 创建的对象

先看参数是否存在，排除了 null 这些， 其后 toString.call
不使用 typeof 因为 window Date document 这些全是 Object 使用 toString.call 可筛选这些

其后获得参数原型

若无原型，证明是 Object.create( null ) 创建的。 *****后期补充 Object.create 知识，继承相关的知识

判断原型的 constructor 是否为 Object() 
简单/朴素对象的原型 constructor 为 function 
toString 为function Object() { [native code] }

function A() {}

var b = new A();

$.isPlainObject(b); // false

b 的 constructor 为 function A() {}


isEmptyObject: function ( obj ) {
	var name;
	for ( name in obj ) {
		return false;
	}
	return true;
}

和自己之前写的判断是否空对象类似


type: function ( obj ) {
	if ( obj == null ) {
		return obj + '';
	}

	return typeof obj === 'object' || typeof === 'function' ?
		class2type[ toString.call( obj ) ] || 'object' :
		typeof obj;
}

jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

jQuery 的 type 遵从了一些 typeof, null 的类型还是 object
但也不遵从 如 Date, typeof 是 object, 变成 date


rmsPrefix = /^-ms-/,
rdashAlpha = /-([a-z])/g,

camelCase: function (string) {
	return string.replace( rmsPrefix, 'ms-' ).replace( rdashAlpha, fcamelCase );
}

将 text-align 这样的值转换为 textAlign
肯定 css 函数里用了


之前做过标记

fcamelCase = function( all, letter ) {
	return letter.toUpperCase();
};

为何来个all，就是参数而已

注意根据 RegExp 不同， replace 第二个参数 function 的 arguments 是不同的


var str = 'ascscabc123';

var a = /abc/g;

var b = /a(b)c/g;

str.replace(a, function () {
    console.log(arguments); // abc, 5, ascscabc123
});

str.replace(b, function () {
    console.log(arguments); // abc, b, 5, ascscabc123
});

若匹配，多一个括号，就多一个 argument 
如果是 /a(b)(c)/g   则是 abc, b, c, 5, ascscabc123


each: function ( obj, callback ) {
	var length, i = 0;

	if ( isArrayLike( obj ) ) {
		length = obj.length;
		for ( ; i < length; i++ ) {
			if ( callback.call( obj[ i ], i, obj[i] ) === false) {
				break;
			}
		}
	} else {
		for ( i in obj ) {
			if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
				break;
			}
		}
	}
}

与原生的 each 很大不同

首先 arguments 只有两个， 依次为 i item

原生的有三个，为 item i array

之后此处是 callback.call( obj[ i ], i, obj[ i ] ) 证明 this 是 item

而原生的 this 是 window (无论是否箭头函数，箭头函数 this 要回顾 *****)

jQuery 的 each 可中断， 原生不可

var a = [{x: 3}, {x: 4}, {x : 5}];

jQuery.each(a, function (i, item) {
	item.x = 666;
	return false;
}); // [{x: 666}, {x: 4}, {x : 5}]


makeArray 把类数组对象 变成数组


grep  linux的检索命令，也就是筛选出符合的 item, 就是filter


proxy 改变函数上下文，就是 bind

proxy: function ( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === 'string' ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	if ( !jQuery.isFunction( fn) ) {
		return undefined;
	}

	// 模拟 bind
	args = slice.call( arguments, 2);
	proxy = function () {
		return fn.apply( context || this, args.concat( slice.call( arguments, ) ) );
	}

	// 这感觉没啥用，原注释也说可以删除
	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
}


isArrayLike 判断是否数组/类数组对象

function isArrayLike( obj ) {
	var length = !!obj && 'length' in obj && obj.length;
		type = jQuery.type( obj );

	if ( type === 'function' || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && ( length - 1) in obj;
}

function 也有 length 属性，为形参个数

function a(x, y, z) {}

console.log(a.length); // 3

window 对象也有 length 属性， length 为 0

此处判断对象是否类数组对象 三个条件

typeof length === 'number' 
&& length > 0 
&& ( length - 1) in obj;



booleans = "checked|selected|async|autofocus|autoplay|controls\
	|defer|disabled|hidden|ismap|loop|multiple|open|readonly\
	|required|scoped",

autoplay video audio  音频及视频自动播放
controls video audio  音频视频控件
loop     video audio  音频视频循环播放
defer    script       仅适用于外部脚本，即使用了 src 属性，当页面加载完成后，才执行脚本
hidden   *            对元素隐藏，比如可以在提交表单时，提交非用户直接输入的数据
ismap    img          没用过没见过，直接复制解释 当用户在 ismap 图像上单击了某处时，浏览器会自动把鼠标的 x、y 位置（相对于图像的左上角）发送到服务器端
multiple input select 多选，input 多个文件，select 多选
open     detail       HTML5 的新标签，如同下拉展现
scoped   style        限定 style 的作用区域，只有 Firefox 支持


whitespace = "[\\x20\\t\\r\\n\\f]",

\x20 表示空格
\t   制表符
\r   回车符
\n   换行符
\f   换页符

identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

先解释 ?:  非捕获正则

前面曾说过

var str = 'ascscabc123';

var a = /abc/g;

var b = /a(b)c/g;

str.replace(a, function () {
    console.log(arguments); // abc, 5, ascscabc123
});

str.replace(b, function () {
    console.log(arguments); // abc, b, 5, ascscabc123
});

若匹配，多一个括号，就多一个 argument 
如果是 /a(b)(c)/g   则是 abc, b, c, 5, ascscabc123

此处若是使用非匹配正则

var c = /a(?:b)c/g;

str.replace(c, function () {
    console.log(arguments); // abc, 5, ascscabc123
});


预匹配，有肯定(?=x)和否定(?!x)两种形式，表示匹配结果后紧跟着x或不能有x（注意匹配结果中不含x）

   'abc'.match(/\w/g)结果为["a","b","c"]
   'abc'.match(/\w(?=b)/g)结果为["a"]
   'abc'.match(/\w(?!b)/g)结果为["b","c"]


四根斜杠 即 两根斜杠
之后用在 new RegExp 则表示一根

. 任意单个字符，换行符除外

[]  查找在方括号内任意一个字符

[\\w-]  \w 任意一个字母或数字或下划线 -中划线

[^\0-\\xa0])+  除了 \0 到 \xa0 的一个或多个字符

具体标识符为何这样写，懒得看文档，太多英文看得晕 ***** 后期看
http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier


attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
	// Operator (capture 2)
	"*([*^$|!~]?=)" + whitespace +
	// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
	"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
	"*\\]",

// \[(?:whitespace)*((?:identifier))(?:(?:whitespace)*([*^$|!~]?=)(?:whitespace)*(?:'((?:\\.|[^\\'])*)'|\"((?:\\.|[^\\\"])*)\"|((?:identifier)))|)(?:whitespace)*\]
// https://jex.im/regulex/#!flags=&re=%5C%5B(%3F%3Awhitespace)*((%3F%3Aidentifier))(%3F%3A(%3F%3Awhitespace)*(%5B*%5E%24%7C!~%5D%3F%3D)(%3F%3Awhitespace)*(%3F%3A'((%3F%3A%5C%5C.%7C%5B%5E%5C%5C'%5D)*)'%7C%5C%22((%3F%3A%5C%5C.%7C%5B%5E%5C%5C%5C%22%5D)*)%5C%22%7C((%3F%3Aidentifier)))%7C)(%3F%3Awhitespace)*%5C%5D
attributes = "\\[whitespace*(identifier)\
(\
	?:whitespace*([*^$|!~]?=)whitespace*\
	(\
		?:'((?:\\\\.|[^\\\\'])*)'|\
		\"((?:\\\\.|[^\\\\\"])*)\"|\
		(identifier)\
	)|\
)whitespace*\\]";



pseudos = ":(" + identifier + "=)(?:\\((" +
	// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	// 1. quoted (capture 3; capture 4 or capture 5)
	"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
	// 2. simple (capture 6)
	"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
	// 3. anything else (capture 2)
	".*" +
	")\\)|)",

//  伪元素匹配
// :((?:identifier)=)(?:\((('((?:\\.|[^\\'])*)'|\"((?:\\.|[^\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|(?:attributes))*)|.*)\)|)
// https://jex.im/regulex/#!flags=&re=%3A((%3F%3Aidentifier)%3D)(%3F%3A%5C((('((%3F%3A%5C%5C.%7C%5B%5E%5C%5C'%5D)*)'%7C%5C%22((%3F%3A%5C%5C.%7C%5B%5E%5C%5C%22%5D)*)%22)%7C((%3F%3A%5C%5C%5C%5C.%7C%5B%5E%5C%5C%5C%5C()%5B%5C%5C%5D%5D%7C(%3F%3Aattributes))*)%7C.*)%5C)%7C)
pseudos = ":(identifier=)\
(\
	?:\\(\
		(\
			(\
				'(\
					(\
						?:\\\\.|[^\\\\']\
					)*\
				)\
				'|\"((?:\\\\.|[^\\\\\"])*)\"\
			)|\
			((?:\\\\.|[^\\\\()[\\]]|attributes)*)|\
		.*)\
	\\)\
|)",


rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

该正则分两部分

^(?:whitespace)+ 或 ((?:^|[^\\])(?:\\.)*)whitespace+$

以空格 1～多次开头
或者 （非\\开头加空格）以空格结尾

以几个实例读懂上面那个正则

(?:^|[^\\]) 会匹配一个不是 '\\' 的任意字符，匹配空字符
若是 则不匹配，只是个 空字符串， (?:\\.) 会匹配'\\字符'

var a = /(?:(^|5)(\\.)*)$/;
var b = '6'
console.log(b.match(a))

var c = /^/;
var d = '7';
console.log(d.match(c));

var e = /^|[^\\]/;
var f = '\\';
console.log(f.match(e));

var g = /((?:^|[^\\])(?:\\.)*)$/;
var h = '\\';
console.log(h.match(g))

var i = /(^)|([^\\])/;
var j = '\\';
console.log(j.match(i));

var k = /\\./;
var l = '\\.';
console.log(l.match(k))

var m = /(?:(^|[^\\])(\\.)*)$/;
var n = '6'
console.log(n.match(m))

var o = /(?:(^|[^\\])(\\.)*)$/;
var p = '\\5'
console.log(p.match(o))

之后看 Sizzle 函数

Sizzle( selector, context, results, seed )  *****坐标记，后面两个参数未知是何？

要求 context 的 nodeType 是  1 或 9 或 11

记忆几个关键的nodeType
1 element
2 attribute
3 text
9 document
11 documentFragment

Sizzle 会优先使用 window 自带的 如 getElementById getElementsByTagNamegetElementsByClassName querySelectorAll
不行再调用 select 函数。
Sizzle 里面有众多前面未有的变量及函数，需后期观看 *****

定义一个 缓存函数
/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

原有注释虽然讲得明明白白，但是未知其作用。
关键未知Expr是啥 *****


/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

这个也未知作用

其中 expando = "sizzle" + 1 * new Date()

目前认为可以作为函数是否已经使用来对待。

其后有定义一个 assert 方法。在关于前端测试中经常可看到改函数
/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

try catch finally 
其中 finally 会在执行完 try 和 catch 后执行

今日在写 async await 中就遇到 try catch
不得不说 async await 实在太好用了
function test(time) {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('ok')
			// reject('error')
		}, time)
	})
}

async function run() {
	console.log('run begin');
	try {
		var result = await test(1500);
		console.log(result);
	} catch (e) {
		console.log(e);
	} finally {
		console.log('run end');
	}
}
run();

接着定义一个 addHandle 方法 为指定的属性添加相同的方法，此处同 createCache 关键未知Expr是啥 *****
/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

接着定以  createInputPseudo  createButtonPseudo  createDisabledPseudo  createPositionalPseudo

其中 createPositionalPseudo 用到了上面提过的 markFunction 整个函数都不知道意义，为位置伪造？也没传 element 
/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

测试上下文？ 这函数也够绝 return context && typeof context.getElementsByTagName !== "undefined" && context; 
链式调用。最后返回 context 但若不存在就返回 false

从未接触过 XML 
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

其中 ownerDocument 返回 document 对象

<p id="a">123</p>
console.log(document.getElementById('a').documentElement) // undefined


其后一个 setDocument ，400行代码的大函数

直接复制他人写的解释

Sizzle的setDocument函数，根据当前文档设置文档相关的变量，参数element or document，返回current document
这个函数主要任务是测试浏览器对相关函数的支持，从而写出兼容的ID，TAG，CLASS的find和filter函数；
测试浏览器对querySelectorAll函数的支持程度，建立对不支持的情况过滤的正则表达式rbuggyQSA；
重写兼容的contains和sortOrder方法。


/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// document.defaultView属性返回当前 document 对象所关联的 window 对象
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	// 反正是排除 ie8 以下的，不管
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	// 检测是否有 getElementsByClassName
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	//  polyfill matches方法
	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

先跳过 Sizzle 了， 太多对浏览器的兼容，看得云里雾里。

jQuery.find = Sizzle;

返回一个数据，且非 jQuery 对象

jQuery.expr = Sizzle.selectors;


定义了个dir函数，看不出作用，跳到后面，看。
until 是一个选择器，直到何处为止，且不包含
比如一个 dom 结构如下
<div id="a">
	<div id="b">
		<div id="c"></div>
	</div>
</div>

$('#c').parentsUntil('#a'); 就是 #b

var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;
	// truncate 英语意思是缩短
	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};

// n 是 elem 的父节点的第一个子节点
var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};

// 匹配 <input /> 单标签
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );

// jQuery each 第二个参数，函数的argument 为 key, value
jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( nodeName( elem, "iframe" ) ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	// selector 为筛选器
	jQuery.fn[ name ] = function( until, selector ) {
		// this 就是调用该函数的对象 如当 $('#c').parentsUntil('body')  this 就是$('#c')
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			// jQuery.uniqueSort( matched ); 把 match的顺序掉放了，调回来
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );

// 相当于一个过滤器，过滤dom
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
			// ( !!qulifier.call( elem, i, elem ) ) !== not
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

// 相当于原生的matches拓展
// expr 为选择器， not 为过滤的选择器
jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

其后 jQuery.fn 拓展 find, filter, not, is 四个方法


find: function( selector ) {
	var i, ret,
		len = this.length,
		self = this;

	// 此为 selector 为 dom 的情况
	if ( typeof selector !== "string" ) {
		return this.pushStack( jQuery( selector ).filter( function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( self[ i ], this ) ) {
					return true;
				}
			}
		} ) );
	}

	ret = this.pushStack( [] );

	for ( i = 0; i < len; i++ ) {
		jQuery.find( selector, self[ i ], ret );
	}

	return len > 1 ? jQuery.uniqueSort( ret ) : ret;
},


init = jQuery.fn.init = function( selector, context, root ) {
	var match, elem;

	// HANDLE: $(""), $(null), $(undefined), $(false)
	if ( !selector ) {
		return this;
	}

	// Method init() accepts an alternate rootjQuery
	// so migrate can support jQuery.sub (gh-2101)
	root = root || rootjQuery;


	// 三种情况 字符串 节点 function
	// Handle HTML strings
	if ( typeof selector === "string" ) {
		if ( selector[ 0 ] === "<" &&
			selector[ selector.length - 1 ] === ">" &&
			selector.length >= 3 ) {

			// Assume that strings that start and end with <> are HTML and skip the regex check
			match = [ null, selector, null ];

		} else {
			// rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
			match = rquickExpr.exec( selector );
			// match[1] 匹配 </w/W>  match[2]匹配 #[(/w-)]+
		}

		// Match html or make sure no context is specified for #id
		if ( match && ( match[ 1 ] || !context ) ) {

			// HANDLE: $(html) -> $(array)
			if ( match[ 1 ] ) {
				context = context instanceof jQuery ? context[ 0 ] : context;

				// Option to run scripts is true for back-compat
				// Intentionally let the error be thrown if parseHTML is not present
				// 此处 parseHTML 返回一个数组，数组长度为1，内容为 document.createElement('xxx')
				jQuery.merge( this, jQuery.parseHTML(
					match[ 1 ],
					context && context.nodeType ? context.ownerDocument || context : document,
					true
				) );

				// HANDLE: $(html, props)
				// 这段代码的作用是给元素标签添加属性
				// $('<div>', {title: '标题'})
				// [<div title="标题"></div>]
				if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
					for ( match in context ) {

						// Properties of context are called as methods if possible
						if ( jQuery.isFunction( this[ match ] ) ) {
							this[ match ]( context[ match ] );

						// ...and otherwise set as attributes
						} else {
							this.attr( match, context[ match ] );
						}
					}
				}

				return this;

				// HANDLE: $(#id)
			} else {
				elem = document.getElementById( match[ 2 ] );

				if ( elem ) {

					// Inject the element directly into the jQuery object
					this[ 0 ] = elem;
					this.length = 1;
				}
				return this;
			}

		// HANDLE: $(expr, $(...))
		} else if ( !context || context.jquery ) {
			return ( context || root ).find( selector );

		// HANDLE: $(expr, context)
		// (which is just equivalent to: $(context).find(expr)
		} else {
			return this.constructor( context ).find( selector );
		}

	// HANDLE: $(DOMElement)
	} else if ( selector.nodeType ) {
		this[ 0 ] = selector;
		this.length = 1;
		return this;

	// HANDLE: $(function)
	// Shortcut for document ready
	} else if ( jQuery.isFunction( selector ) ) {
		return root.ready !== undefined ?
			root.ready( selector ) :

				// Execute immediately if ready is not present
			selector( jQuery );
	}

	return jQuery.makeArray( selector, this );
};


jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};
