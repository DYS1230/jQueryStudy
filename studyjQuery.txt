版本 3.2.1

注 未看标记为*****

jQuery 代码结构分析

首先定义一堆私有变量

记录变量，或者单看看不c出意思的。

var class2type = {};

var toString = class2type.toString;   // 猜测为toString.call(variable)

null -> [object Null]
undefiend -> [object Undefiend]
new Date() -> [object Date]
new ClassA() -> [obect Object]


之后补充个知识

typeof Object
// "function"
typeof Object()
// "object"

因为 Object 是一个构造函数

其后再补充 Function 与 Object

https://segmentfault.com/q/1010000002736664
https://segmentfault.com/q/1010000000249140

目前感觉很绕，需抽空研究

var hasOwn = class2type.hasOwnProperty;

{}.hasOwnProperty 与 Object.prototype.hasOwnProperty 相同

因为 {} 与 new Object()

但是不要忘了 {} 与 Object.prototype 是不同的

例： hasOwnProperty 判断是否含有特定的自身属性

{}.hasOwnProperty('toString');  // false
Object.prototype.hasOwnProperty('toString'); // true

补充 for in 是会遍历原型链的，但是不会遍历不可枚举的属性

再补充 in 可以是不可枚举属性
'toString' in {}; // true

Object.getOwnPropertyNames 就可以输出 hasOwnProperty 的所有属性
Object.keys 是只能输出可枚举的

以上两个均是自身特定的，不会遍历原型链

var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call( Object );

如果要循环全部 需要一层一层原型链遍历
使用 Object.getPrototypeOf

类似这样 while (obj = Object.getPrototypeOf(obj));


var fnToString = hasOwn.toString;


直接调用 fnToString() 是会报错的，一开始用 FireBug 一直不知道错在哪，
一直报错 TypeError: Function.prototype.toString called on incompatible object
其后用 Chrome 报错 Uncaught TypeError: Function.prototype.toString requires that 'this' be a Function
明显多了，this 改动了，虽然不知道toString的源码是什么，但也能判断出来大概。

以 Object 做判断 

var a = {b: 1};

var b = a.toString;

b();

FireBug 输出是 "[object Window]"
Chrome 输出是 "[object Undefined]"

可知源码必是用了 this 来输出结果

根据知乎 https://www.zhihu.com/question/19636194 方应杭的答案

this 三中调用形式

func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2)


看第一种

function func() {
	console.log(this)
}

func();

可等价为 func.call(undefiend) // 可简写为 func.call()

按理就是 undefined, 但浏览器中如果你传的 context 不是一个对象，那么 window 对象就是默认的 context。
（这条规则在 Node.js 和 strict 模式下会稍微不一样，不过那不是我们现在要讨论的）

看第二种

var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo();

可等价为 obj.foo.call(obj), this 就是 obj 了

看第三种

直接定了 context 了


现在可以知道了，举个例子

Object.prototype.test = function () {
	console.log(this);
}

var a = {x: 1};

a.test();  // 此处this就是a

var b = a.test;

b(); // 此处this就是window


之后知乎里面一道 this 的题目

var a = 10;
function test() {
    a = 5;
	console.log(a);
	console.log(this.a);
	var a;
	console.log(this.a);
	console.log(a);
}

问：执行test()和new test() 返回值分别为啥？

此处涉及变量提前

a = 10;
var a;
console.log(a);

输出的是 10

答案是 5 10 10 5
       5 undefined undefined 5



function DOMEval( code, doc ) {
	doc = doc || document;

	var script = doc.createElement( "script" );

	script.text = code;
	doc.head.appendChild( script ).parentNode.removeChild( script );
}

appendChild 后立马 removeChild

单看认为是实现 once 功能
但自己目前对这样写的实际效果保持怀疑


jQuery = function( selector, context ) {
	// The jQuery object is actually just the init constructor 'enhanced'
	// Need init if jQuery is called (just allow error to be thrown if not included)
	return new jQuery.fn.init( selector, context );
},

猜能猜到是创建一个jQuery对象
目前该函数尚未遇见，做个标记*****。


rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

https://imququ.com/post/bom-and-javascript-trim.html

 \uFEFF。它是 ES5 新增的空白符，叫字节次序标记字符（Byte Order Mark），也就是 BOM 字符。


fcamelCase = function( all, letter ) {
	return letter.toUpperCase();
};

作为 replace 的第二个参数


其后定义了 jQuery.fn


提前看
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

就是把两个数组或类数组对象合并


pushStack: function( elems ) {
	// Build a new jQuery matched element set
	var ret = jQuery.merge( this.constructor(), elems );
	
	// Add the old object onto the stack (as a reference)
	ret.prevObject = this;

	// Return the newly-formed element set
	return ret;
},

即创建一个新的jQuery对象，且放入新的elem，原先的扔在pervObject

目前可以取消链式调用的方法，如 eq find 等等都用了此函数，jQuery 的强大的链式调用关键方法

做标记***** 遇到 end 回来距离用

做标记***** 后期 jQuery 的方法与 underscore 比较 (each, map 这些)


定义 jQuery 与 jQuery.fn 的 extend 方法

照着敲了一遍

jQuery.extend = jQuery.fn.extend = function () {
	var options, name, src, copy, copyIsArray, clone,
	    target = arguments[ 0 ] || {},
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// 函数重载，判断是否深复制，默认浅复制
	if ( typeof target === 'boolean' ) {
		deep = target;

		target = arguments[i] || {};
		i++;
	}

	// 处理target为string或其他的情况，可能发生在深复制
	if ( typeof target !== 'object' && !jQuery.isFunction ( target) ) {
		target = {};
	}

	// 当只有一个参数时，extend jQuery 自己本身
	if (i === length) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// 感觉此处不合理，用 != 而不是 !== 而且为了排除null与undefined
		// 用 if (options) 更好
		// for in 对null 和 undefined 也不会报错
		if ( ( options = arguments[ i ] ) != null ) {

			for ( name in options) {
				src = target[ name ];
				copy = options[ name ];

				// 防止无限递归的对象
				// var a = {b: 1}
				// extend(a, {x: a});
				if (target === copy ) {
					continue;
				}

				// recurse 递归
				if ( deep && copy && jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy )) {

					if ( copyIsArray ) {
						// 目前不清楚为何要重置copyIsArray，完全没作用
						// 然而是有很大作用的，因为此次为循环，且copyIsArray是“或”语句，因此需要重置copyIsArray
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];
					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					target[ name ] = jQuery.extend( deep, clone, copy);
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	return target;
}


extend 函数补充知识点

关于typeof

typeof null === 'object';
typeof [1, 2, 3] === 'object'; 

// instaitated with  与...联系在一起
// All constructor function while instaitated with 'new' keyword will always be typeof 'object'
typeof new Number(100) === 'object';
// But there is a exception in case of Function constructor of Javascript
typeof new Function() === 'function';

typeof /s/ === 'function'; // Non-conform to ECMAScript 5.1
typeof /s/ === 'object';   // Conform to ECMAScript 5.1

关于 for in

var str = 'abc';
for (var key in str) {
	console.log(key);
}

// 0
// 1
// 2


紧接着 extend jQuery 对象
一堆 isXXX 函数 
此处也是够6，我应该不敢这么写，此处应该是算 jQuery 奇淫技巧之一。
extend 函数用到了需要 extend 的函数。
如 jQuery 本身没有 isFunction 但是 extend 函数用了 isFunction
isFunction 是需要 extend 的属性


expando 是 expandable object 的缩写,表示可扩展的对象


目前未知 noop 是干什么的，跟本没用到

介绍 isWindow

isWindow: function ( obj ) {
	return obj != null && obj === obj.window
}

window 对象的 window 属性指向他自己本身，截取段 MDN 的解释
The window property of a window object points to the window object itself. Thus the following expressions all return the same window object

介绍 isNumeric 

isNumeric: function ( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)	
	var type = jQuery.type( obj );
	return ( type === 'number' || type === 'string') &&
	
		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
}

那堆英语我也不知道怎么翻译

先判断是否 数字 或 字符串
且 !isNaN( obj - parseFloat( obj ) )

一开始有个疑惑，为甚不直接 obj - obj

是为了排除 '' 即空字符串的情况

其后补充知识

减法会强制转换类型

null '' Boolean值 都会强制转换为数字

parseFloat 则没这种情况，但是 parseFloat 有其他问题
其会将'Ox15'这样的值转换为 0 
会将 [6, 8] 数组转换成第一个数字(空数组没问题，对象也没问题)


isPlainObject: function ( obj ) {
	var proto, Ctor;

	if ( !obj || toString.call( obj ) !== '[object object]') {
		return false;
	}

	proto = getProto( obj );

	if ( !proto ) {
		return true;
	}

	Ctor = hasOwn.call( proto, 'constructor' ) && proto.constructor;
	return typeof Ctor === 'function' && fnToString.call( Ctor) === ObjectFunctionString
}

判断对象是否简单对象，即使用 {} 或 new Object 创建的对象

先看参数是否存在，排除了 null 这些， 其后 toString.call
不使用 typeof 因为 window Date document 这些全是 Object 使用 toString.call 可筛选这些

其后获得参数原型

若无原型，证明是 Object.create( null ) 创建的。 *****后期补充 Object.create 知识，继承相关的知识

判断原型的 constructor 是否为 Object() 
简单/朴素对象的原型 constructor 为 function 
toString 为function Object() { [native code] }

function A() {}

var b = new A();

$.isPlainObject(b); // false

b 的 constructor 为 function A() {}


isEmptyObject: function ( obj ) {
	var name;
	for ( name in obj ) {
		return false;
	}
	return true;
}

和自己之前写的判断是否空对象类似


type: function ( obj ) {
	if ( obj == null ) {
		return obj + '';
	}

	return typeof obj === 'object' || typeof === 'function' ?
		class2type[ toString.call( obj ) ] || 'object' :
		typeof obj;
}

jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

jQuery 的 type 遵从了一些 typeof, null 的类型还是 object
但也不遵从 如 Date, typeof 是 object, 变成 date


rmsPrefix = /^-ms-/,
rdashAlpha = /-([a-z])/g,

camelCase: function (string) {
	return string.replace( rmsPrefix, 'ms-' ).replace( rdashAlpha, fcamelCase );
}

将 text-align 这样的值转换为 textAlign
肯定 css 函数里用了


之前做过标记

fcamelCase = function( all, letter ) {
	return letter.toUpperCase();
};

为何来个all，就是参数而已

注意根据 RegExp 不同， replace 第二个参数 function 的 arguments 是不同的


var str = 'ascscabc123';

var a = /abc/g;

var b = /a(b)c/g;

str.replace(a, function () {
    console.log(arguments); // abc, 5, ascscabc123
});

str.replace(b, function () {
    console.log(arguments); // abc, b, 5, ascscabc123
});

若匹配，多一个括号，就多一个 argument 
如果是 /a(b)(c)/g   则是 abc, b, c, 5, ascscabc123


each: function ( obj, callback ) {
	var length, i = 0;

	if ( isArrayLike( obj ) ) {
		length = obj.length;
		for ( ; i < length; i++ ) {
			if ( callback.call( obj[ i ], i, obj[i] ) === false) {
				break;
			}
		}
	} else {
		for ( i in obj ) {
			if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
				break;
			}
		}
	}
}

与原生的 each 很大不同

首先 arguments 只有两个， 依次为 i item

原生的有三个，为 item i array

之后此处是 callback.call( obj[ i ], i, obj[ i ] ) 证明 this 是 item

而原生的 this 是 window (无论是否箭头函数，箭头函数 this 要回顾 *****)

jQuery 的 each 可中断， 原生不可

var a = [{x: 3}, {x: 4}, {x : 5}];

jQuery.each(a, function (i, item) {
	item.x = 666;
	return false;
}); // [{x: 666}, {x: 4}, {x : 5}]


makeArray 把类数组对象 变成数组


grep  linux的检索命令，也就是筛选出符合的 item, 就是filter


proxy 改变函数上下文，就是 bind

proxy: function ( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === 'string' ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	if ( !jQuery.isFunction( fn) ) {
		return undefined;
	}

	// 模拟 bind
	args = slice.call( arguments, 2);
	proxy = function () {
		return fn.apply( context || this, args.concat( slice.call( arguments, ) ) );
	}

	// 这感觉没啥用，原注释也说可以删除
	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
}


isArrayLike 判断是否数组/类数组对象

function isArrayLike( obj ) {
	var length = !!obj && 'length' in obj && obj.length;
		type = jQuery.type( obj );

	if ( type === 'function' || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && ( length - 1) in obj;
}

function 也有 length 属性，为形参个数

function a(x, y, z) {}

console.log(a.length); // 3

window 对象也有 length 属性， length 为 0

此处判断对象是否类数组对象 三个条件

typeof length === 'number' 
&& length > 0 
&& ( length - 1) in obj;



booleans = "checked|selected|async|autofocus|autoplay|controls\
	|defer|disabled|hidden|ismap|loop|multiple|open|readonly\
	|required|scoped",

autoplay video audio  音频及视频自动播放
controls video audio  音频视频控件
loop     video audio  音频视频循环播放
defer    script       仅适用于外部脚本，即使用了 src 属性，当页面加载完成后，才执行脚本
hidden   *            对元素隐藏，比如可以在提交表单时，提交非用户直接输入的数据
ismap    img          没用过没见过，直接复制解释 当用户在 ismap 图像上单击了某处时，浏览器会自动把鼠标的 x、y 位置（相对于图像的左上角）发送到服务器端
multiple input select 多选，input 多个文件，select 多选
open     detail       HTML5 的新标签，如同下拉展现
scoped   style        限定 style 的作用区域，只有 Firefox 支持


whitespace = "[\\x20\\t\\r\\n\\f]",

\x20 表示空格
\t   制表符
\r   回车符
\n   换行符
\f   换页符

identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

先解释 ?:  非捕获正则

前面曾说过

var str = 'ascscabc123';

var a = /abc/g;

var b = /a(b)c/g;

str.replace(a, function () {
    console.log(arguments); // abc, 5, ascscabc123
});

str.replace(b, function () {
    console.log(arguments); // abc, b, 5, ascscabc123
});

若匹配，多一个括号，就多一个 argument 
如果是 /a(b)(c)/g   则是 abc, b, c, 5, ascscabc123

此处若是使用非匹配正则

var c = /a(?:b)c/g;

str.replace(c, function () {
    console.log(arguments); // abc, 5, ascscabc123
});


预匹配，有肯定(?=x)和否定(?!x)两种形式，表示匹配结果后紧跟着x或不能有x（注意匹配结果中不含x）

   'abc'.match(/\w/g)结果为["a","b","c"]
   'abc'.match(/\w(?=b)/g)结果为["a"]
   'abc'.match(/\w(?!b)/g)结果为["b","c"]


四根斜杠 即 两根斜杠
之后用在 new RegExp 则表示一根

. 任意单个字符，换行符除外

[]  查找在方括号内任意一个字符

[\\w-]  \w 任意一个字母或数字或下划线 -中划线

[^\0-\\xa0])+  除了 \0 到 \xa0 的一个或多个字符

具体标识符为何这样写，懒得看文档，太多英文看得晕 ***** 后期看
http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier


attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
	// Operator (capture 2)
	"*([*^$|!~]?=)" + whitespace +
	// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
	"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
	"*\\]",

// \[(?:whitespace)*((?:identifier))(?:(?:whitespace)*([*^$|!~]?=)(?:whitespace)*(?:'((?:\\.|[^\\'])*)'|\"((?:\\.|[^\\\"])*)\"|((?:identifier)))|)(?:whitespace)*\]
// https://jex.im/regulex/#!flags=&re=%5C%5B(%3F%3Awhitespace)*((%3F%3Aidentifier))(%3F%3A(%3F%3Awhitespace)*(%5B*%5E%24%7C!~%5D%3F%3D)(%3F%3Awhitespace)*(%3F%3A'((%3F%3A%5C%5C.%7C%5B%5E%5C%5C'%5D)*)'%7C%5C%22((%3F%3A%5C%5C.%7C%5B%5E%5C%5C%5C%22%5D)*)%5C%22%7C((%3F%3Aidentifier)))%7C)(%3F%3Awhitespace)*%5C%5D
attributes = "\\[whitespace*(identifier)\
(\
	?:whitespace*([*^$|!~]?=)whitespace*\
	(\
		?:'((?:\\\\.|[^\\\\'])*)'|\
		\"((?:\\\\.|[^\\\\\"])*)\"|\
		(identifier)\
	)|\
)whitespace*\\]";



pseudos = ":(" + identifier + "=)(?:\\((" +
	// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	// 1. quoted (capture 3; capture 4 or capture 5)
	"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
	// 2. simple (capture 6)
	"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
	// 3. anything else (capture 2)
	".*" +
	")\\)|)",

//  伪元素匹配
// :((?:identifier)=)(?:\((('((?:\\.|[^\\'])*)'|\"((?:\\.|[^\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|(?:attributes))*)|.*)\)|)
// https://jex.im/regulex/#!flags=&re=%3A((%3F%3Aidentifier)%3D)(%3F%3A%5C((('((%3F%3A%5C%5C.%7C%5B%5E%5C%5C'%5D)*)'%7C%5C%22((%3F%3A%5C%5C.%7C%5B%5E%5C%5C%22%5D)*)%22)%7C((%3F%3A%5C%5C%5C%5C.%7C%5B%5E%5C%5C%5C%5C()%5B%5C%5C%5D%5D%7C(%3F%3Aattributes))*)%7C.*)%5C)%7C)
pseudos = ":(identifier=)\
(\
	?:\\(\
		(\
			(\
				'(\
					(\
						?:\\\\.|[^\\\\']\
					)*\
				)\
				'|\"((?:\\\\.|[^\\\\\"])*)\"\
			)|\
			((?:\\\\.|[^\\\\()[\\]]|attributes)*)|\
		.*)\
	\\)\
|)",


rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

该正则分两部分

^(?:whitespace)+ 或 ((?:^|[^\\])(?:\\.)*)whitespace+$

以空格 1～多次开头
或者 （非\\开头加空格）以空格结尾

以几个实例读懂上面那个正则

(?:^|[^\\]) 会匹配一个不是 '\\' 的任意字符，匹配空字符
若是 则不匹配，只是个 空字符串， (?:\\.) 会匹配'\\字符'

var a = /(?:(^|5)(\\.)*)$/;
var b = '6'
console.log(b.match(a))

var c = /^/;
var d = '7';
console.log(d.match(c));

var e = /^|[^\\]/;
var f = '\\';
console.log(f.match(e));

var g = /((?:^|[^\\])(?:\\.)*)$/;
var h = '\\';
console.log(h.match(g))

var i = /(^)|([^\\])/;
var j = '\\';
console.log(j.match(i));

var k = /\\./;
var l = '\\.';
console.log(l.match(k))

var m = /(?:(^|[^\\])(\\.)*)$/;
var n = '6'
console.log(n.match(m))

var o = /(?:(^|[^\\])(\\.)*)$/;
var p = '\\5'
console.log(p.match(o))

之后看 Sizzle 函数

Sizzle( selector, context, results, seed )  *****坐标记，后面两个参数未知是何？

要求 context 的 nodeType 是  1 或 9 或 11

记忆几个关键的nodeType
1 element
2 attribute
3 text
9 document
11 documentFragment

Sizzle 会优先使用 window 自带的 如 getElementById getElementsByTagNamegetElementsByClassName querySelectorAll
不行再调用 select 函数。
Sizzle 里面有众多前面未有的变量及函数，需后期观看 *****

定义一个 缓存函数
/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

原有注释虽然讲得明明白白，但是未知其作用。
关键未知Expr是啥 *****


/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

这个也未知作用

其中 expando = "sizzle" + 1 * new Date()

目前认为可以作为函数是否已经使用来对待。

其后有定义一个 assert 方法。在关于前端测试中经常可看到改函数
/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

try catch finally 
其中 finally 会在执行完 try 和 catch 后执行

今日在写 async await 中就遇到 try catch
不得不说 async await 实在太好用了
function test(time) {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('ok')
			// reject('error')
		}, time)
	})
}

async function run() {
	console.log('run begin');
	try {
		var result = await test(1500);
		console.log(result);
	} catch (e) {
		console.log(e);
	} finally {
		console.log('run end');
	}
}
run();

接着定义一个 addHandle 方法 为指定的属性添加相同的方法，此处同 createCache 关键未知Expr是啥 *****
/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

接着定以  createInputPseudo  createButtonPseudo  createDisabledPseudo  createPositionalPseudo

其中 createPositionalPseudo 用到了上面提过的 markFunction 整个函数都不知道意义，为位置伪造？也没传 element 
/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

测试上下文？ 这函数也够绝 return context && typeof context.getElementsByTagName !== "undefined" && context; 
链式调用。最后返回 context 但若不存在就返回 false

从未接触过 XML 
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

其中 ownerDocument 返回 document 对象

<p id="a">123</p>
console.log(document.getElementById('a').documentElement) // undefined


其后一个 setDocument ，400行代码的大函数

直接复制他人写的解释

Sizzle的setDocument函数，根据当前文档设置文档相关的变量，参数element or document，返回current document
这个函数主要任务是测试浏览器对相关函数的支持，从而写出兼容的ID，TAG，CLASS的find和filter函数；
测试浏览器对querySelectorAll函数的支持程度，建立对不支持的情况过滤的正则表达式rbuggyQSA；
重写兼容的contains和sortOrder方法。


/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// document.defaultView属性返回当前 document 对象所关联的 window 对象
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	// 反正是排除 ie8 以下的，不管
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	// 检测是否有 getElementsByClassName
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	//  polyfill matches方法
	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

先跳过 Sizzle 了， 太多对浏览器的兼容，看得云里雾里。

jQuery.find = Sizzle;

返回一个数据，且非 jQuery 对象

jQuery.expr = Sizzle.selectors;


定义了个dir函数，看不出作用，跳到后面，看。
until 是一个选择器，直到何处为止，且不包含
比如一个 dom 结构如下
<div id="a">
	<div id="b">
		<div id="c"></div>
	</div>
</div>

$('#c').parentsUntil('#a'); 就是 #b

dir 属性
var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;
	// truncate 英语意思是缩短
	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};

// n 是 elem 的父节点的第一个子节点
var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};

// 匹配 <input /> 单标签
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );

// jQuery each 第二个参数，函数的argument 为 key, value
jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( nodeName( elem, "iframe" ) ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	// selector 为筛选器
	jQuery.fn[ name ] = function( until, selector ) {
		// this 就是调用该函数的对象 如当 $('#c').parentsUntil('body')  this 就是$('#c')
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			// jQuery.uniqueSort( matched ); 把 match的顺序掉放了，调回来
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );

// 相当于一个过滤器，过滤dom
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
			// ( !!qulifier.call( elem, i, elem ) ) !== not
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

// 相当于原生的matches拓展
// expr 为选择器， not 为过滤的选择器
jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

其后 jQuery.fn 拓展 find, filter, not, is 四个方法


find: function( selector ) {
	var i, ret,
		len = this.length,
		self = this;

	// 此为 selector 为 dom 的情况
	if ( typeof selector !== "string" ) {
		return this.pushStack( jQuery( selector ).filter( function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( self[ i ], this ) ) {
					return true;
				}
			}
		} ) );
	}

	ret = this.pushStack( [] );

	for ( i = 0; i < len; i++ ) {
		jQuery.find( selector, self[ i ], ret );
	}

	return len > 1 ? jQuery.uniqueSort( ret ) : ret;
},


init = jQuery.fn.init = function( selector, context, root ) {
	var match, elem;

	// HANDLE: $(""), $(null), $(undefined), $(false)
	if ( !selector ) {
		return this;
	}

	// Method init() accepts an alternate rootjQuery
	// so migrate can support jQuery.sub (gh-2101)
	root = root || rootjQuery;


	// 
	console.log($([99, 2, 3], {
		a: function () {
			console.log(5)
		},
		title: '55'
	})[0]);
三种情况 字符串 节点 function
	// Handle HTML strings
	if ( typeof selector === "string" ) {
		if ( selector[ 0 ] === "<" &&
			selector[ selector.length - 1 ] === ">" &&
			selector.length >= 3 ) {

			// Assume that strings that start and end with <> are HTML and skip the regex check
			match = [ null, selector, null ];

		} else {
			// rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
			match = rquickExpr.exec( selector );
			// match[1] 匹配 </w/W>  match[2]匹配 #[(/w-)]+
		}

		// Match html or make sure no context is specified for #id
		if ( match && ( match[ 1 ] || !context ) ) {

			// HANDLE: $(html) -> $(array)
			if ( match[ 1 ] ) {
				context = context instanceof jQuery ? context[ 0 ] : context;

				// Option to run scripts is true for back-compat
				// Intentionally let the error be thrown if parseHTML is not present
				// 此处 parseHTML 返回一个数组，数组长度为1，内容为 document.createElement('xxx')
				jQuery.merge( this, jQuery.parseHTML(
					match[ 1 ],
					context && context.nodeType ? context.ownerDocument || context : document,
					true
				) );

				// HANDLE: $(html, props)
				// 这段代码的作用是给元素标签添加属性
				// $('<div>', {title: '标题'})
				// [<div title="标题"></div>]
				if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
					for ( match in context ) {

						// Properties of context are called as methods if possible
						// this 就是 jQuery,fn.init
						if ( jQuery.isFunction( this[ match ] ) ) {
							this[ match ]( context[ match ] );

						// ...and otherwise set as attributes
						} else {
							this.attr( match, context[ match ] );
						}
					}
				}

				return this;

				// HANDLE: $(#id)
			} else {
				elem = document.getElementById( match[ 2 ] );

				if ( elem ) {

					// Inject the element directly into the jQuery object
					this[ 0 ] = elem;
					this.length = 1;
				}
				return this;
			}

		// HANDLE: $(expr, $(...))
		// jQuery.find = Sizzle;
		} else if ( !context || context.jquery ) {
			return ( context || root ).find( selector );

		// HANDLE: $(expr, context)
		// (which is just equivalent to: $(context).find(expr)
		} else {
			return this.constructor( context ).find( selector );
		}

	// HANDLE: $(DOMElement)
	} else if ( selector.nodeType ) {
		this[ 0 ] = selector;
		this.length = 1;
		return this;

	// HANDLE: $(function)
	// Shortcut for document ready
	// 当参数为函数时，调用了ready方法，
	// 所以，$(function(){})这种写法算是文档加载$(document).ready(function(){})的一种简写方式。
	} else if ( jQuery.isFunction( selector ) ) {
		return root.ready !== undefined ?
			root.ready( selector ) :

				// Execute immediately if ready is not present
			selector( jQuery );
	}

	return jQuery.makeArray( selector, this );
};

// 将字符串转换成节点
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


fn 拓展 has  closest index add addBack 属性


	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			看自己前面的兄弟个数
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},


	add: function( selector, context ) {
		// 放入栈中
		return this.pushStack(
			jQuery.uniqueSort(
				// this.get() 自己本身DOM
				// jQuery 是所有的 selector包含
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		// prevObject 具体看 pushStack
		// 如 $('#a').children().addBack();
		// prevObject 是 $('#a')
		// 之后调用 add 的 this 是 $('#a').children()
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}

var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );

// 将字符串设为对象  如 once memory   变为 {once: true, memory: true}
// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}


// callbacks 函数详解 https://segmentfault.com/a/1190000004331027
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
			
			// list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] )
			// options.stopOnFalse
			// 就停止

			// 此处 list 可能会递归， firing 该变量的作用就在此处
			// var callbacks = $.Callbacks( "memory" );
			// callbacks.add(function(value) { return callbacks.add(function(value) { console.log(value) }) });
			// callbacks.fire( "foo" );
			// callbacks.add(function(value) { return callbacks.add(function(value) { console.log(value) }) });
			// 若没有 firing 会死循环
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			// 看是否要记忆，是的话 memory就是 queue.shift()
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			// locked 会把 监听器清空，若memory为true，会设为空数组，否则为空字符串
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}
					// 添加监听器进入 list
					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					// 执行队列
					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					// 浅复制
					args = [ context, args.slice ? args.slice() : args ];
					// 加入一个
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

			// action, add listener, callbacks,
			// ... .then handlers, argument index, [final state]
			// 以上为各个参数意义
			[ "notify", "progress", jQuery.Callbacks( "memory" ), jQuery.Callbacks( "memory" ), 2 ],
			[ "resolve", "done", jQuery.Callbacks( "once memory" ), jQuery.Callbacks( "once memory" ), 0, "resolved" ],
			[ "reject", "fail", jQuery.Callbacks( "once memory" ), jQuery.Callbacks( "once memory" ), 1, "rejected" ]
		]
		var state = "pending",
		var promise = {
			state: function() {
				return state;
			},
			always: function() {
				deferred.done( arguments ).fail( arguments );
				return this;
			},
			"catch": function( fn ) {
				return promise.then( null, fn );
			},

			// Keep pipe for back-compat
			// 不看，已经不赞成使用的属性
			pipe: function( /* fnDone, fnFail, fnProgress */ ) {
				var fns = arguments;

				return jQuery.Deferred( function( newDefer ) {
					jQuery.each( tuples, function( i, tuple ) {

						// Map tuples (progress, done, fail) to arguments (done, fail, progress)
						var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

						// 为add
						// deferred.progress(function() { bind to newDefer or newDefer.notify })
						// deferred.done(function() { bind to newDefer or newDefer.resolve })
						// deferred.fail(function() { bind to newDefer or newDefer.reject })
						deferred[ tuple[ 1 ] ]( function() {
							var returned = fn && fn.apply( this, arguments );
							if ( returned && jQuery.isFunction( returned.promise ) ) {
								returned.promise()
									.progress( newDefer.notify )
									.done( newDefer.resolve )
									.fail( newDefer.reject );
							} else {
								newDefer[ tuple[ 0 ] + "With" ](
									this,
									fn ? [ returned ] : arguments
								);
							}
						} );
					} );
					fns = null;
				} ).promise();
			},
			then: function( onFulfilled, onRejected, onProgress ) {
				var maxDepth = 0;
				// 深度？ 
				//deferred对象，有具有属性notify notifyWith reject rejectWith resolve resolveWith
				// 及promise对象的属性，即 always catch 等的属性的对象
				// handler 处理函数
				// special fireWith函数
				function resolve( depth, deferred, handler, special ) {

					// 0,
					// newDefer,
					// jQuery.isFunction( onProgress ) ?
					// 	onProgress :
					// 	Identity,
					// newDefer.notifyWith
					return function() {

							
						// 变成 undefined
						var that = this;
						// 也 undifined
						var args = arguments;

						mightThrow = function() {
							var returned, then;

							// Support: Promises/A+ section 2.3.3.3.3
							// https://promisesaplus.com/#point-59
							// Ignore double-resolution attempts
							if ( depth < maxDepth ) {
								return;
							}

							returned = handler.apply( that, args );

							// Support: Promises/A+ section 2.3.1
							// https://promisesaplus.com/#point-48
							if ( returned === deferred.promise() ) {
								throw new TypeError( "Thenable self-resolution" );
							}

							// Support: Promises/A+ sections 2.3.3.1, 3.5
							// https://promisesaplus.com/#point-54
							// https://promisesaplus.com/#point-75
							// Retrieve `then` only once
							then = returned &&

								// Support: Promises/A+ section 2.3.4
								// https://promisesaplus.com/#point-64
								// Only check objects and functions for thenability
								( typeof returned === "object" ||
									typeof returned === "function" ) &&
								returned.then;

								// Handle a returned thenable
							if ( jQuery.isFunction( then ) ) {

								// Special processors (notify) just wait for resolution
								if ( special ) {
									then.call(
										returned,
										resolve( maxDepth, deferred, Identity, special ),
										resolve( maxDepth, deferred, Thrower, special )
										);

								// Normal processors (resolve) also hook into progress
								} else {

									// ...and disregard older resolution values
									maxDepth++;

									then.call(
										returned,
										resolve( maxDepth, deferred, Identity, special ),
										resolve( maxDepth, deferred, Thrower, special ),
										resolve( maxDepth, deferred, Identity,
											deferred.notifyWith )
									);
								}

							// Handle all other returned values
							} else {

								// Only substitute handlers pass on context
								// and multiple values (non-spec behavior)
								if ( handler !== Identity ) {
									that = undefined;
									args = [ returned ];
								}

								// Process the value(s)
								// Default process is resolve
								// resolveWith 触发
								( special || deferred.resolveWith )( that, args );
							}
						},

						// Only normal processors (resolve) catch and reject exceptions
						// 没有 special
						process = special ?
							mightThrow :
							function() {
								try {
									mightThrow();
								} catch ( e ) {

									if ( jQuery.Deferred.exceptionHook ) {
										jQuery.Deferred.exceptionHook( e,
											process.stackTrace );
									}

									// Support: Promises/A+ section 2.3.3.3.4.1
									// https://promisesaplus.com/#point-61
									// Ignore post-resolution exceptions
									if ( depth + 1 >= maxDepth ) {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Thrower ) {
											that = undefined;
											args = [ e ];
										}

										deferred.rejectWith( that, args );
									}
								}
							};

						// Support: Promises/A+ section 2.3.3.3.1
						// https://promisesaplus.com/#point-57
						// Re-resolve promises immediately to dodge false rejection from
						// subsequent errors
						if ( depth ) {
							process();
						} else {

							// Call an optional hook to record the stack, in case of exception
							// since it's otherwise lost when execution goes async
							if ( jQuery.Deferred.getStackHook ) {
								process.stackTrace = jQuery.Deferred.getStackHook();
							}
							// 加入定时器中
							window.setTimeout( process );
						}
					};
				}


				// jQuery.Deferred 生成一个具有属性notify notifyWith reject rejectWith resolve resolveWith
				// 及promise对象的属性，即 always catch 等的属性的对象
				// 此处传入 fn 参数
				// 比直接 jQuery.Deferred 多调用 func.call( deferred, deferred ); 注意其中的deferred就是新生成的 那个对象， 
				// this 变为 newDefer 且传入 fn 一个 argument， 即 newDefer
				return jQuery.Deferred( function( newDefer ) {
					// 一次在 progress , done, fail 上加上传入的三个函数,
					// 非直接加， 通过resolve(....)加

					// progress_handlers.add( ... )
					// resolve 返回一个函数


					tuples[ 0 ][ 3 ].add(
						resolve(
							0,
							newDefer,
							jQuery.isFunction( onProgress ) ?
								onProgress :
								Identity,
							newDefer.notifyWith
						)
					);

					// fulfilled_handlers.add( ... )
					// 此处若tuples[ 1 ][ 3 ] 是有 memory 的
					// 比如执行了 resove();
					// 那就会调用 resolve 这个函数返回的那个函数
					tuples[ 1 ][ 3 ].add(
						resolve(
							0,
							newDefer,
							jQuery.isFunction( onFulfilled ) ?
								onFulfilled :
								Identity
						)
					);

					// rejected_handlers.add( ... )
					tuples[ 2 ][ 3 ].add(
						resolve(
							0,
							newDefer,
							jQuery.isFunction( onRejected ) ?
								onRejected :
								Thrower
						)
					);
				} ).promise();
			},

			// Get a promise for this deferred
			// If obj is provided, the promise aspect is added to the object
			promise: function( obj ) {
				return obj != null ? jQuery.extend( obj, promise ) : promise;
			}
		},
		deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ]; // callbacks('memory') callbacks('once memory') callbacks('once memory')
			var stateString = tuple[ 5 ]; // undefined resolved rejected

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// tuples 的 2 是 cb
					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};
		} );

		// Make the deferred a promise
		// 最关键的，不知道这句代码的执行
		// deferred属性notify notifyWith reject rejectWith resolve resolveWith
		// promise.promise( deferred ) 这句话为 deferred 添加 promise对象的属性，即 always catch 等的属性
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			// 此处是生成 [empty * i];
			resolveContexts = Array( i ),
			// 浅复制
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			// subordinate 附属的，次要的
			// 这是 resolve 函数
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					// 当remaining 没了，就执行master.resoveWith，且传入的是最后一个完成的上下文
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			// master.done( updateFunc( i ) ) 相当于 master.add add返回的是 this，即返回master
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
				// 返回 then，反正then后面也是 return jQuery.Deferred( function () {} ).promise(); 目前未知为何返回then *****
				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );

// 就是为value 的done加上 resolve 和 fail加上 reject 方法
function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			// method.call( value ) 一个promise对象
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		// 其他有then方法的
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}



// The deferred used on DOM ready
var readyList = jQuery.Deferred();

// 在 readyList 执行后执行 fn
jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		// 触发promise，jQuery.fn.ready(fn)绑定函数都被触发,$(function () { console.log(arguments); }) 比如这个绑定的 console
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
// 执行完后去除定时器
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}


window.onload 指 页面包含图片等文件在内的所有元素都加载完成
$() 则是 DOMContentLoaded

之后设置一个 Data 类

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				// 如果节点不能 stringify 或者 循环 直接赋值
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},


Object.defineProperty(obj, prop, descriptor);

value: 设置属性的值
writable: 值是否可以重写。true | false
enumerable: 目标属性是否可以被枚举。true | false
configurable: 目标属性是否可以被删除或是否可以再次修改特性(特性就是这四个) true | false

一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false

比如　
Object.defineProperty( owner, this.expando, {
	value: value,
	configurable: true
} );

其默认的 writable 与 enumerable 就是 false

data在jQuery中有两种

一个是用来存数据的, 对应的对象分别是

存储对象: data_user

获取与设置方法: $.data(el, key, value)

另一个是用来存事件的, 如click事件那种, 对应的对象分别是

存储对象: data_priv

获取与设置方法: $._data(el, key, value)

data_user和data_priv, 就如其名, 一个是用户用的, 一个是jQuery私有的, 他们都是一个叫Data的实例对象

	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},

这个方法既是 getter，也是 setter，如此而已。它存在的原因是由于 jQuery 的 API 有很多是身兼 setter 和 getter 的功能，比如 .data、.html、.text。有了 access 可以少写很多 if / else。

getter 条件

key 是 undefined，这时取整个 cache
key 是字符串且value 是undefined，这是取指定 key 的值

setter 条件

owner、key、value 这三个参数都传




data有什么作用？

在我们平时js编码过程中，我们经常会向DOM元素中添加各种自定义属性，这样有一个弊端。

  1、假设我们在DOM元素中添加了一个属性，这个属性指向了某个js对象。dom1.ele = jsObj

  2、当这个js对象发挥完作用后，我们已经用不到他了。这时候按理说应该把这个js变量清空，释放内存。大家都知道，如果一个js对象不存在任何外在引用的话，解释器会自动将其在内存中删除，这也是javascript相对于c++等手动管理内存的程序的优点。

  3、但是这时候问题来了，因为DOM元素引用了这个js对象，尽管这个js对象已经没有存在的意义了，但是解释器是不会把他删除的。如果想要把其删除，我们可能需要将DOM元素的这个属性设置为null。

  4、我们编写了这么多的代码，哪里能把 每个js对象是不是被DOM元素引用了都记住啊？

  5、而且，假如DOM元素与js对象之间相互循环引用，根本就无法删除！ 这就是内存泄漏

  6、所以，为了避免这种情况的发生，我们要尽量避免 引用数据(这里的引用数据可以说是javascript对象) 直接依附在DOM对象上。

  7、data就是用来搞定以上问题的方法。


Data 上有 cache  set  get  access  remove   hasData  七个方法

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};

fn 上有 data 方法， 即$('#a').data('bb', 'cc');

jQuery 上有 hasData data removeData， 这个是 data_user 的
		 _data， _removeData 是 data_priv 的


可以尝试

$(document).click(function () {
	console.log(1);
})

var x = $._data(document);
console.log(x);


其后 jQuery 定义 queue 与 dequeue， 是加在 data_priv 上的

	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			// 不传 type 就是 fx
			type = ( type || "fx" ) + "queue";
			// 此处的 queue 是引用
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				// 传入数组会将全部变成数组的，之前的消失
				// 无 队列，则创一个数组
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},


	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			// 添加一个进程标记以防止fx队列被自动出队
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			// hooks stop 属性何处来的
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			// 把 type + "queue" 与 type + "queueHooks" 两个属性清除
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		// 给 dataPriv 添加个 key: { empty : callbackObj }
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}


jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		// 当 type 为 string 且 data 无传入时
		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		// data 无传入 且  type 不是 string 时， 直接返回 this
		return data === undefined ?
			this :
			this.each( function() {
				// 为 this 的 queue 传入 data
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				// 第一个 fx 直接执行
				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					// 此处执行后 queue[ 0 ] 就是 inprogress 了
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			// 此处似乎无任何意义，反正会执行 type = type || 'fx'
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		// 如果 count 为 1， 直接执行 resolveWith(elements, [elements]) 而且执行这，仅是代表改变 promise 的状态罢了，因为 defer 没有啥函数挂载
		resolve();
		// 此处执行的是 jQuery.extend( obj, promise )
		return defer.promise( obj );
	}
} );

promise 理解的例子

function ff1() {
    console.log(1)
}
function ff2() {
      console.log(2);
}
function succ() {
      console.log('done');
}
$body = $('body')
$body.queue('mx', ff1);
$body.queue('mx', ff2);
 
var promise = $body.promise('mx');
promise.then(succ);
 
setInterval(function() {
    $body.dequeue('mx') // 先弹出1,2，最后是"done"
}, 1500)


// 把 elem 的 style 替换成 options 的， 之后执行 callback，callback 的 this 是 elem， arguments 是 args
var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var defaultDisplayMap = {};
 
 // 先在 body 中创建， 之后删除，是 jQuery 的一贯技巧
function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

// 若 show 为 true，把 display 为 none 的 展现为默认的，如 span 就变回 inline-block， 但如果 span 本身内联style是 block， 那还是设为 block
// 若 show 为 false，把 display 设为 none，且记下原先 内联style 设置的 display
function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			// 此处 if 为看 非内联style下是否 style 为 none
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

// 获得 所有 tag || * 的DOM
function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			// 无传 refElements 就直接设为 true， 若传了，取refELements的globalEval
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}



//https://www.cnblogs.com/snandy/p/5760742.html
//https://www.cnblogs.com/aaronjs/p/3510768.html
function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// 3 种情形
			// elem 是 DOM 元素（根据nodeType判断），直接放入 nodes 数组中
			// elem 是字符串且不是 HTML tag，创建文本节点对象（textNode），放入 nodes 数组中
			// elem 是字符串且是 HTML tag，将其转成 DOM 元素，放入 nodes 数组中
			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				// tmp 是 context.createElement('div');
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				
				//jQuery.htmlPrefilter( elem )   return elem.replace( rxhtmlTag, "<$1></$2>" );
				// 即 会把 <div/> 设为 <div></div>
				// 如果 tmp 是 td 这些 ，需要 把 其包裹起来, 包上<table><tbody><tr>", "</tr></tbody></table>
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		// 获取 elem 中的script
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	// cloneNode() 方法创建节点的拷贝，并返回该副本。
	// cloneNode() 方法克隆所有属性以及它们的值。
	// 如果您需要克隆所有后代，请把 deep 参数设置 true，否则设置为 false。
	// 此处两个 cloneNode 是为了兼容
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();

// checkClone 与 noCloneChecked 都为true


// activeElement 属性返回文档中当前获得焦点的元素。
// 注意： 该属性是只读的。
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}


jQuery 的 event 很复杂


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	// 附加数据可以为任意类型
	// var userObj = { name: "DYS", age: 23 };

	// 为所有p元素绑定click事件，并传入附加数据(user)
	// $("p").on( "click", userObj, function(event){
	// 	console.log( event.data.name );
	// } );

	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

其后

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},

	...

} );

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

event 对象的属性

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );
			// 此处的 elemData 为 引用

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		// Caller可以传入自定义数据的对象来代替handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		// 确保无效的选择器在附加时抛出异常。
		// 在elem是非元素节点（例如，文档）的情况下针对documentElement进行评估
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		// 初始化
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}

		// 同样为初始化，初始elemData.handle
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				// 抛弃jQuery.event.trigger（）的第二个事件，并在页面卸载后调用事件
				// arguments 就是 e
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			// 根据新的 type 重置 special
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			// 首次初始化
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = []; // 将 events[type] 设成数组
				handlers.delegateCount = 0;
				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// $(document).click(function () {
					// 	console.log(123);
					// });
					// $(document).click(function () {
					// 	console.log(456);
					// })
					// getEventListeners(document); // {click: Array(1)}
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	// Datach 脱离
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		// length 至少为1
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					// 从dataPriv 的 events 的 type 的数组中清除
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}
				// 再 删除 events
				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},