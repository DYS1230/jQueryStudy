版本 3.2.1

注 未看标记为*****

jQuery 代码结构分析

首先定义一堆私有变量

记录变量，或者单看看不出意思的。

var class2type = {};

var toString = class2type.toString;   // 猜测为toString.call(variable)

null -> [object Null]
undefiend -> [object Undefiend]
new Date() -> [object Date]
new ClassA() -> [obect Object]


之后补充个知识

typeof Object
// "function"
typeof Object()
// "object"

因为 Object 是一个构造函数

其后再补充 Function 与 Object

https://segmentfault.com/q/1010000002736664
https://segmentfault.com/q/1010000000249140

目前感觉很绕，需抽空研究

var hasOwn = class2type.hasOwnProperty;

{}.hasOwnProperty 与 Object.prototype.hasOwnProperty 相同

因为 {} 与 new Object()

但是不要忘了 {} 与 Object.prototype 是不同的

例： hasOwnProperty 判断是否含有特定的自身属性

{}.hasOwnProperty('toString');  // false
Object.prototype.hasOwnProperty('toString'); // true

补充 for in 是会遍历原型链的，但是不会遍历不可枚举的属性

再补充 in 可以是不可枚举属性
'toString' in {}; // true

Object.getOwnPropertyNames 就可以输出 hasOwnProperty 的所有属性
Object.keys 是只能输出可枚举的

以上两个均是自身特定的，不会遍历原型链

var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call( Object );

如果要循环全部 需要一层一层原型链遍历
使用 Object.getPrototypeOf

类似这样 while (obj = Object.getPrototypeOf(obj));


var fnToString = hasOwn.toString;


直接调用 fnToString() 是会报错的，一开始用 FireBug 一直不知道错在哪，
一直报错 TypeError: Function.prototype.toString called on incompatible object
其后用 Chrome 报错 Uncaught TypeError: Function.prototype.toString requires that 'this' be a Function
明显多了，this 改动了，虽然不知道toString的源码是什么，但也能判断出来大概。

以 Object 做判断 

var a = {b: 1};

var b = a.toString;

b();

FireBug 输出是 "[object Window]"
Chrome 输出是 "[object Undefined]"

可知源码必是用了 this 来输出结果

根据知乎 https://www.zhihu.com/question/19636194 方应杭的答案

this 三中调用形式

func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2)


看第一种

function func() {
	console.log(this)
}

func();

可等价为 func.call(undefiend) // 可简写为 func.call()

按理就是 undefined, 但浏览器中如果你传的 context 不是一个对象，那么 window 对象就是默认的 context。
（这条规则在 Node.js 和 strict 模式下会稍微不一样，不过那不是我们现在要讨论的）

看第二种

var obj = {
  foo: function(){
    console.log(this)
  }
}

obj.foo();

可等价为 obj.foo.call(obj), this 就是 obj 了

看第三种

直接定了 context 了


现在可以知道了，举个例子

Object.prototype.test = function () {
	console.log(this);
}

var a = {x: 1};

a.test();  // 此处this就是a

var b = a.test;

b(); // 此处this就是window


之后知乎里面一道 this 的题目

var a = 10;
function test() {
    a = 5;
	console.log(a);
	console.log(this.a);
	var a;
	console.log(this.a);
	console.log(a);
}

问：执行test()和new test() 返回值分别为啥？

此处涉及变量提前

a = 10;
var a;
console.log(a);

输出的是 10

答案是 5 10 10 5
       5 undefined undefined 5



function DOMEval( code, doc ) {
	doc = doc || document;

	var script = doc.createElement( "script" );

	script.text = code;
	doc.head.appendChild( script ).parentNode.removeChild( script );
}

appendChild 后立马 removeChild

单看认为是实现 once 功能
但自己目前对这样写的实际效果保持怀疑


jQuery = function( selector, context ) {
	// The jQuery object is actually just the init constructor 'enhanced'
	// Need init if jQuery is called (just allow error to be thrown if not included)
	return new jQuery.fn.init( selector, context );
},

猜能猜到是创建一个jQuery对象
目前该函数尚未遇见，做个标记*****。


rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

https://imququ.com/post/bom-and-javascript-trim.html

 \uFEFF。它是 ES5 新增的空白符，叫字节次序标记字符（Byte Order Mark），也就是 BOM 字符。


fcamelCase = function( all, letter ) {
	return letter.toUpperCase();
};

作为 replace 的第二个参数


其后定义了 jQuery.fn


提前看
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

就是把两个数组或类数组对象合并


pushStack: function( elems ) {
	// Build a new jQuery matched element set
	var ret = jQuery.merge( this.constructor(), elems );
	
	// Add the old object onto the stack (as a reference)
	ret.prevObject = this;

	// Return the newly-formed element set
	return ret;
},

即创建一个新的jQuery对象，且放入新的elem，原先的扔在pervObject

目前可以取消链式调用的方法，如 eq find 等等都用了此函数，jQuery 的强大的链式调用关键方法

做标记***** 遇到 end 回来距离用

做标记***** 后期 jQuery 的方法与 underscore 比较 (each, map 这些)


定义 jQuery 与 jQuery.fn 的 extend 方法

照着敲了一遍

jQuery.extend = jQuery.fn.extend = function () {
	var options, name, src, copy, copyIsArray, clone,
	    target = arguments[ 0 ] || {},
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// 函数重载，判断是否深复制，默认浅复制
	if ( typeof target === 'boolean' ) {
		deep = target;

		target = arguments[i] || {};
		i++;
	}

	// 处理target为string或其他的情况，可能发生在深复制
	if ( typeof target !== 'object' && !jQuery.isFunction ( target) ) {
		target = {};
	}

	// 当只有一个参数时，extend jQuery 自己本身
	if (i === length) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// 感觉此处不合理，用 != 而不是 !== 而且为了排除null与undefined
		// 用 if (options) 更好
		// for in 对null 和 undefined 也不会报错
		if ( ( options = arguments[ i ] ) != null ) {

			for ( name in options) {
				src = target[ name ];
				copy = options[ name ];

				// 防止无限递归的对象
				// var a = {b: 1}
				// extend(a, {x: a});
				if (target === copy ) {
					continue;
				}

				// recurse 递归
				if ( deep && copy && jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy )) {

					if ( copyIsArray ) {
						// 目前不清楚为何要重置copyIsArray，完全没作用
						// 然而是有很大作用的，因为此次为循环，且copyIsArray是“或”语句，因此需要重置copyIsArray
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];
					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					target[ name ] = jQuery.extend( deep, clone, copy);
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	return target;
}


extend 函数补充知识点

关于typeof

typeof null === 'object';
typeof [1, 2, 3] === 'object'; 

// instaitated with  与...联系在一起
// All constructor function while instaitated with 'new' keyword will always be typeof 'object'
typeof new Number(100) === 'object';
// But there is a exception in case of Function constructor of Javascript
typeof new Function() === 'function';

typeof /s/ === 'function'; // Non-conform to ECMAScript 5.1
typeof /s/ === 'object';   // Conform to ECMAScript 5.1

关于 for in

var str = 'abc';
for (var key in str) {
	console.log(key);
}

// 0
// 1
// 2


紧接着 extend jQuery 对象
一堆 isXXX 函数 
此处也是够6，我应该不敢这么写，此处应该是算 jQuery 奇淫技巧之一。
extend 函数用到了需要 extend 的函数。
如 jQuery 本身没有 isFunction 但是 extend 函数用了 isFunction
isFunction 是需要 extend 的属性


expando 是 expandable object 的缩写,表示可扩展的对象


目前未知 noop 是干什么的，跟本没用到

介绍 isWindow

isWindow: function ( obj ) {
	return obj != null && obj === obj.window
}

window 对象的 window 属性指向他自己本身，截取段 MDN 的解释
The window property of a window object points to the window object itself. Thus the following expressions all return the same window object

介绍 isNumeric 

isNumeric: function ( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)	
	var type = jQuery.type( obj );
	return ( type === 'number' || type === 'string') &&
	
		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
}

那堆英语我也不知道怎么翻译

先判断是否 数字 或 字符串
且 !isNaN( obj - parseFloat( obj ) )

一开始有个疑惑，为甚不直接 obj - obj

是为了排除 '' 即空字符串的情况

其后补充知识

减法会强制转换类型

null '' Boolean值 都会强制转换为数字

parseFloat 则没这种情况，但是 parseFloat 有其他问题
其会将'Ox15'这样的值转换为 0 
会将 [6, 8] 数组转换成第一个数字(空数组没问题，对象也没问题)


isPlainObject: function ( obj ) {
	var proto, Ctor;

	if ( !obj || toString.call( obj ) !== '[object object]') {
		return false;
	}

	proto = getProto( obj );

	if ( !proto ) {
		return true;
	}

	Ctor = hasOwn.call( proto, 'constructor' ) && proto.constructor;
	return typeof Ctor === 'function' && fnToString.call( Ctor) === ObjectFunctionString
}

判断对象是否简单对象，即使用 {} 或 new Object 创建的对象

先看参数是否存在，排除了 null 这些， 其后 toString.call
不使用 typeof 因为 window Date document 这些全是 Object 使用 toString.call 可筛选这些

其后获得参数原型

若无原型，证明是 Object.create( null ) 创建的。 *****后期补充 Object.create 知识，继承相关的知识

判断原型的 constructor 是否为 Object() 
简单/朴素对象的原型 constructor 为 function 
toString 为function Object() { [native code] }

function A() {}

var b = new A();

$.isPlainObject(b); // false

b 的 constructor 为 function A() {}


isEmptyObject: function ( obj ) {
	var name;
	for ( name in obj ) {
		return false;
	}
	return true;
}

和自己之前写的判断是否空对象类似


type: function ( obj ) {
	if ( obj == null ) {
		return obj + '';
	}

	return typeof obj === 'object' || typeof === 'function' ?
		class2type[ toString.call( obj ) ] || 'object' :
		typeof obj;
}

jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

jQuery 的 type 遵从了一些 typeof, null 的类型还是 object
但也不遵从 如 Date, typeof 是 object, 变成 date


rmsPrefix = /^-ms-/,
rdashAlpha = /-([a-z])/g,

camelCase: function (string) {
	return string.replace( rmsPrefix, 'ms-' ).replace( rdashAlpha, fcamelCase );
}

将 text-align 这样的值转换为 textAlign
肯定 css 函数里用了


之前做过标记

fcamelCase = function( all, letter ) {
	return letter.toUpperCase();
};

为何来个all，就是参数而已

注意根据 RegExp 不同， replace 第二个参数 function 的 arguments 是不同的


var str = 'ascscabc123';

var a = /abc/g;

var b = /a(b)c/g;

str.replace(a, function () {
    console.log(arguments); // abc, 5, ascscabc123
});

str.replace(b, function () {
    console.log(arguments); // abc, b, 5, ascscabc123
});

若匹配，多一个括号，就多一个 argument 
如果是 /a(b)(c)/g   则是 abc, b, c, 5, ascscabc123


each: function ( obj, callback ) {
	var length, i = 0;

	if ( isArrayLike( obj ) ) {
		length = obj.length;
		for ( ; i < length; i++ ) {
			if ( callback.call( obj[ i ], i, obj[i] ) === false) {
				break;
			}
		}
	} else {
		for ( i in obj ) {
			if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
				break;
			}
		}
	}
}

与原生的 each 很大不同

首先 arguments 只有两个， 依次为 i item

原生的有三个，为 item i array

之后此处是 callback.call( obj[ i ], i, obj[ i ] ) 证明 this 是 item

而原生的 this 是 window (无论是否箭头函数，箭头函数 this 要回顾 *****)

jQuery 的 each 可中断， 原生不可

var a = [{x: 3}, {x: 4}, {x : 5}];

jQuery.each(a, function (i, item) {
	item.x = 666;
	return false;
}); // [{x: 666}, {x: 4}, {x : 5}]


makeArray 把类数组对象 变成数组


grep  linux的检索命令，也就是筛选出符合的 item, 就是filter


proxy 改变函数上下文，就是 bind

proxy: function ( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === 'string' ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	if ( !jQuery.isFunction( fn) ) {
		return undefined;
	}

	// 模拟 bind
	args = slice.call( arguments, 2);
	proxy = function () {
		return fn.apply( context || this, args.concat( slice.call( arguments, ) ) );
	}

	// 这感觉没啥用，原注释也说可以删除
	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
}


isArrayLike 判断是否数组/类数组对象

function isArrayLike( obj ) {
	var length = !!obj && 'length' in obj && obj.length;
		type = jQuery.type( obj );

	if ( type === 'function' || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && ( length - 1) in obj;
}

function 也有 length 属性，为形参个数

function a(x, y, z) {}

console.log(a.length); // 3

window 对象也有 length 属性， length 为 0

此处判断对象是否类数组对象 三个条件

typeof length === 'number' 
&& length > 0 
&& ( length - 1) in obj;



booleans = "checked|selected|async|autofocus|autoplay|controls\
	|defer|disabled|hidden|ismap|loop|multiple|open|readonly\
	|required|scoped",

autoplay video audio  音频及视频自动播放
controls video audio  音频视频控件
loop     video audio  音频视频循环播放
defer    script       仅适用于外部脚本，即使用了 src 属性，当页面加载完成后，才执行脚本
hidden   *            对元素隐藏，比如可以在提交表单时，提交非用户直接输入的数据
ismap    img          没用过没见过，直接复制解释 当用户在 ismap 图像上单击了某处时，浏览器会自动把鼠标的 x、y 位置（相对于图像的左上角）发送到服务器端
multiple input select 多选，input 多个文件，select 多选
open     detail       HTML5 的新标签，如同下拉展现
scoped   style        限定 style 的作用区域，只有 Firefox 支持


whitespace = "[\\x20\\t\\r\\n\\f]",

\x20 表示空格
\t   制表符
\r   回车符
\n   换行符
\f   换页符

identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

先解释 ?:  非捕获正则

前面曾说过

var str = 'ascscabc123';

var a = /abc/g;

var b = /a(b)c/g;

str.replace(a, function () {
    console.log(arguments); // abc, 5, ascscabc123
});

str.replace(b, function () {
    console.log(arguments); // abc, b, 5, ascscabc123
});

若匹配，多一个括号，就多一个 argument 
如果是 /a(b)(c)/g   则是 abc, b, c, 5, ascscabc123

此处若是使用非匹配正则

var c = /a(?:b)c/g;

str.replace(c, function () {
    console.log(arguments); // abc, 5, ascscabc123
});


四根斜杠 即 两根斜杠
之后用在 new RegExp 则表示一根

. 任意单个字符，换行符除外

[]  查找在方括号内任意一个字符

[\\w-]  \w 任意一个字母或数字或下划线 -中划线

[^\0-\\xa0])+  除了 \0 到 \xa0 的一个或多个字符

具体标识符为何这样写，懒得看文档，太多英文看得晕 ***** 后期看
http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier


attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
	// Operator (capture 2)
	"*([*^$|!~]?=)" + whitespace +
	// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
	"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
	"*\\]",

// \[(?:whitespace)*((?:identifier))(?:(?:whitespace)*([*^$|!~]?=)(?:whitespace)*(?:'((?:\\.|[^\\'])*)'|\"((?:\\.|[^\\\"])*)\"|((?:identifier)))|)(?:whitespace)*\]
// https://jex.im/regulex/#!flags=&re=%5C%5B(%3F%3Awhitespace)*((%3F%3Aidentifier))(%3F%3A(%3F%3Awhitespace)*(%5B*%5E%24%7C!~%5D%3F%3D)(%3F%3Awhitespace)*(%3F%3A'((%3F%3A%5C%5C.%7C%5B%5E%5C%5C'%5D)*)'%7C%5C%22((%3F%3A%5C%5C.%7C%5B%5E%5C%5C%5C%22%5D)*)%5C%22%7C((%3F%3Aidentifier)))%7C)(%3F%3Awhitespace)*%5C%5D
attributes = "\\[whitespace*(identifier)\
(\
	?:whitespace*([*^$|!~]?=)whitespace*\
	(\
		?:'((?:\\\\.|[^\\\\'])*)'|\
		\"((?:\\\\.|[^\\\\\"])*)\"|\
		(identifier)\
	)|\
)whitespace*\\]";



pseudos = ":(" + identifier + "=)(?:\\((" +
	// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	// 1. quoted (capture 3; capture 4 or capture 5)
	"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
	// 2. simple (capture 6)
	"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
	// 3. anything else (capture 2)
	".*" +
	")\\)|)",

//  伪元素匹配
// :((?:identifier)=)(?:\((('((?:\\.|[^\\'])*)'|\"((?:\\.|[^\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|(?:attributes))*)|.*)\)|)
// https://jex.im/regulex/#!flags=&re=%3A((%3F%3Aidentifier)%3D)(%3F%3A%5C((('((%3F%3A%5C%5C.%7C%5B%5E%5C%5C'%5D)*)'%7C%5C%22((%3F%3A%5C%5C.%7C%5B%5E%5C%5C%22%5D)*)%22)%7C((%3F%3A%5C%5C%5C%5C.%7C%5B%5E%5C%5C%5C%5C()%5B%5C%5C%5D%5D%7C(%3F%3Aattributes))*)%7C.*)%5C)%7C)
pseudos = ":(identifier=)\
(\
	?:\\(\
		(\
			(\
				'(\
					(\
						?:\\\\.|[^\\\\']\
					)*\
				)\
				'|\"((?:\\\\.|[^\\\\\"])*)\"\
			)|\
			((?:\\\\.|[^\\\\()[\\]]|attributes)*)|\
		.*)\
	\\)\
|)",


rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

该正则分两部分

^(?:whitespace)+ 或 ((?:^|[^\\])(?:\\.)*)$

以空格 1～多次开头
或者 （非\\开头加空格）以空格结尾

var a = /(?:(^|5)(\\.)*)$/;
var b = '6'
console.log(b.match(a))

var c = /^/;
var d = '7';
console.log(d.match(c));

var e = /^|[^\\]/;
var f = '\\';
console.log(f.match(e));

var g = /((?:^|[^\\])(?:\\.)*)$/;
var h = '\\';
console.log(h.match(g))

var i = /(^)|([^\\])/;
var j = '\\';
console.log(j.match(i));

var k = /\\./;
var l = '\\.';
console.log(l.match(k))

var m = /(?:(^|[^\\])(\\.)*)$/;
var n = '6'
console.log(n.match(m))

var o = /(?:(^|[^\\])(\\.)*)$/;
var p = '\\5'
console.log(p.match(o))



ie 有个bug getelementbyid() 参数可为name ，未验证 反正ie8没有